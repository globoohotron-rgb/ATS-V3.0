# tools/patchkit.psm1
$PSDefaultParameterValues['Out-File:Encoding'] = 'utf8'
function New-PatchBackup {
  param([string[]]$Paths,[string]$OutDir = "scripts/_backup/patches")
  if(!(Test-Path $OutDir)){ New-Item -ItemType Directory -Force -Path $OutDir | Out-Null }
  $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'
  $dest  = Join-Path $OutDir $stamp
  New-Item -ItemType Directory -Force -Path $dest | Out-Null
  foreach($p in $Paths){ if(Test-Path $p){ Copy-Item $p (Join-Path $dest (Split-Path $p -Leaf)) -Force } }
  return @{Dir=$dest; Stamp=$stamp}
}
function Get-Text { param([string]$Path) if(!(Test-Path $Path)){throw "No file: $Path"}; Get-Content $Path -Raw }
function Set-Text { param([string]$Path,[string]$Text) Set-Content -LiteralPath $Path -Value $Text -Encoding UTF8 }
function Get-Regex { param([string]$Pattern,[System.Text.RegularExpressions.RegexOptions]$Options = 'Multiline', [int]$TimeoutSec = 2)
  return [regex]::new($Pattern, $Options, [TimeSpan]::FromSeconds($TimeoutSec)) }
function Insert-AfterPattern {
  param([string]$Path,[string]$Pattern,[string[]]$Lines,[switch]$Once=$true)
  $rx = Get-Regex $Pattern 'Multiline'
  $arr = Get-Content $Path
  $idx = ($arr | ForEach-Object {$_}) | Select-String -Pattern $rx | Select-Object -First 1 | ForEach-Object { $_.LineNumber-1 }
  if($null -eq $idx){ return $false }
  $before = if($idx -ge 0){ $arr[0..$idx] } else { @() }
  $after  = if($idx -lt $arr.Count-1){ $arr[($idx+1)..($arr.Count-1)] } else { @() }
  $new = @() + $before + $Lines + $after
  Set-Content $Path -Value $new -Encoding UTF8
  return $true
}
function Replace-BetweenMarkers {
  param([string]$Path,[string]$Start,[string]$End,[string[]]$Replacement)
  $rxStart = Get-Regex $Start 'Multiline'
  $rxEnd   = Get-Regex $End 'Multiline'
  $txt = Get-Text $Path
  $m1 = $rxStart.Match($txt); if(-not $m1.Success){ return $false }
  $m2 = $rxEnd.Match($txt,$m1.Index+$m1.Length); if(-not $m2.Success){ return $false }
  $new = $txt.Substring(0,$m1.Index + $m1.Length) + "`r`n" + ($Replacement -join "`r`n") + "`r`n" + $txt.Substring($m2.Index)
  Set-Text $Path $new; return $true
}
function Ensure-BlockByMarkers {
  param([string]$Path,[string]$StartMarker,[string]$EndMarker,[string[]]$Lines)
  $ok = Replace-BetweenMarkers -Path $Path -Start $StartMarker -End $EndMarker -Replacement $Lines
  if(-not $ok){
    # append at end with markers
    $block = @(); $block += $StartMarker; $block += $Lines; $block += $EndMarker
    Add-Content -LiteralPath $Path -Value ($block -join "`r`n") -Encoding UTF8
  }
  return $true
}
function Replace-Regex {
  param([string]$Path,[string]$Pattern,[string]$Replacement,[switch]$Single=$true)
  $rx = Get-Regex $Pattern 'Singleline,Multiline'
  $txt = Get-Text $Path
  $count = 0
  $new = $rx.Replace($txt, { param($m) $script:count++; return $Replacement }, $(if($Single){1}else{[int]::MaxValue}))
  if($count -gt 0){ Set-Text $Path $new; return $true } else { return $false }
}
function Test-ParseScript {
  param([string]$Path)
  $tokens=$null; $errors=$null
  [System.Management.Automation.Language.Parser]::ParseFile($Path,[ref]$tokens,[ref]$errors) | Out-Null
  return @{$true = ($errors.Count -eq 0); Errors=$errors}
}
Export-ModuleMember -Function * -Alias *
